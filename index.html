<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Game</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        body.theory-mode {
            background: #fff5f5;
        }

        h1 {
            color: #344861;
            font-size: 2.5rem;
            margin-bottom: 15px;
        }

        .theory-banner {
            display: none;
            background: #ffebee;
            color: #d32f2f;
            padding: 12px 30px;
            border-radius: 30px;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            animation: pulse-banner 2s infinite;
        }

        .theory-banner.active {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        @keyframes pulse-banner {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .difficulty-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .difficulty-btn {
            padding: 10px 20px;
            border: 2px solid #344861;
            border-radius: 25px;
            background: transparent;
            color: #344861;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .difficulty-btn:hover {
            background: #e2ebf3;
        }

        .difficulty-btn.active {
            background: #344861;
            color: white;
            border-color: #344861;
            font-weight: 600;
        }

        .settings-container {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        .setting-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #344861;
            font-size: 14px;
        }

        .setting-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .setting-item label {
            cursor: pointer;
        }

        .check-answers-btn {
            padding: 8px 16px;
            border: 2px solid #344861;
            border-radius: 20px;
            background: transparent;
            color: #344861;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .check-answers-btn:hover {
            background: #e2ebf3;
        }

        .check-answers-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .stats-bar {
            display: flex;
            gap: 30px;
            color: #344861;
            font-size: 1.1rem;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .timer {
            font-family: monospace;
            font-size: 1.3rem;
        }

        .pause-btn {
            background: #e2ebf3;
            border: none;
            color: #344861;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .pause-btn:hover {
            background: #d0dcea;
        }

        .game-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }

        .board-wrapper {
            position: relative;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            background: #344861;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
            border: 2px solid #344861;
        }

        .theory-mode .board {
            border: 2px solid #d32f2f;
            box-shadow: 0 5px 20px rgba(211, 47, 47, 0.3);
        }

        .cell {
            width: 52px;
            height: 52px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.1s;
            border: 1px solid #bec6d4;
            position: relative;
            color: #325aaf;
        }

        .cell:hover {
            background: #e2ebf3;
        }

        .cell.border-right {
            border-right: 2px solid #344861;
        }

        .cell.border-bottom {
            border-bottom: 2px solid #344861;
        }

        /* Highlighting hierarchy */
        .cell.highlighted-row-col {
            background: #e2ebf3;
        }

        .cell.highlighted-box {
            background: #e2ebf3;
        }

        .cell.same-number {
            background: #c3d7ea;
        }

        .cell.selected {
            background: #bbdefb;
        }

        .cell.hover-highlight {
            background: #c3d7ea;
        }

        .cell.given {
            color: #344861;
            font-weight: 700;
        }

        .cell.correct {
            color: #325aaf;
        }

        /* Error styling */
        .cell.error {
            color: #e55c6c;
            background: #f7cfd6;
        }

        .cell.error.selected {
            background: #f7cfd6;
        }

        .cell.error.highlighted-row-col,
        .cell.error.highlighted-box,
        .cell.error.same-number {
            background: #f7cfd6;
        }

        /* When hovering/selecting same number as an error cell */
        .cell.same-number-error {
            background: #f7cfd6;
        }

        .cell.revealed-error {
            background: #f7cfd6;
            color: #e55c6c;
        }

        .cell.theory-placed {
            color: #9c27b0;
            font-style: italic;
        }

        .notes-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            padding: 2px;
        }

        .note {
            font-size: 11px;
            color: #6e7f8d;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
            border-radius: 2px;
            transition: all 0.1s;
        }

        .note.highlighted-note {
            color: #325aaf;
            font-weight: 700;
            font-size: 13px;
            background: #bbdefb;
            transform: scale(1.1);
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .number-pad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .number-btn {
            width: 60px;
            height: 70px;
            border: none;
            border-radius: 8px;
            background: #f0f4f8;
            font-size: 26px;
            font-weight: 600;
            color: #325aaf;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.08);
        }

        .number-btn:hover:not(.completed) {
            transform: translateY(-2px);
            background: #e2ebf3;
            box-shadow: 0 4px 10px rgba(0,0,0,0.12);
        }

        .number-btn:active:not(.completed) {
            transform: translateY(0);
        }

        .number-btn.completed {
            opacity: 0.35;
            cursor: default;
        }

        .number-btn .count {
            font-size: 11px;
            color: #9e9e9e;
            margin-top: 2px;
        }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .action-btn {
            padding: 14px 20px;
            border: none;
            border-radius: 8px;
            background: #f0f4f8;
            font-size: 14px;
            font-weight: 500;
            color: #344861;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.08);
        }

        .action-btn:hover:not(:disabled) {
            background: #e2ebf3;
            transform: translateY(-1px);
        }

        .action-btn.notes-active {
            background: #325aaf;
            color: white;
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .theory-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
            padding-top: 15px;
            border-top: 2px dashed #bec6d4;
        }

        .theory-btn {
            padding: 14px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.08);
        }

        .theory-btn.enter {
            background: #325aaf;
            color: white;
        }

        .theory-btn.enter:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(50, 90, 175, 0.3);
        }

        .theory-btn.apply {
            background: #4caf50;
            color: white;
        }

        .theory-btn.apply:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(76, 175, 80, 0.3);
        }

        .theory-btn.revert {
            background: #e55c6c;
            color: white;
        }

        .theory-btn.revert:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(229, 92, 108, 0.3);
        }

        .theory-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .keyboard-info {
            background: #f0f4f8;
            padding: 12px;
            border-radius: 8px;
            color: #344861;
            font-size: 12px;
            line-height: 1.6;
        }

        .keyboard-info strong {
            display: block;
            margin-bottom: 5px;
        }

        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(52, 72, 97, 0.95);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 10;
        }

        .pause-overlay .icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .pause-overlay .text {
            font-size: 1.2rem;
        }

        .resume-btn {
            margin-top: 20px;
            padding: 12px 30px;
            background: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            color: #344861;
            font-weight: 600;
        }

        .resume-btn:hover {
            background: #f0f0f0;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .modal {
            background: white;
            padding: 40px 50px;
            border-radius: 20px;
            text-align: center;
            animation: popIn 0.3s ease-out;
            max-width: 90%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }

        @keyframes popIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .modal .icon {
            font-size: 4rem;
            margin-bottom: 15px;
        }

        .modal h2 {
            color: #4caf50;
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .modal p {
            color: #666;
            margin-bottom: 5px;
            font-size: 1.1rem;
        }

        .modal .stats {
            color: #888;
            margin-bottom: 25px;
        }

        .modal .play-again-btn {
            padding: 15px 40px;
            background: #325aaf;
            color: white;
            border: none;
            border-radius: 30px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .modal .play-again-btn:hover {
            transform: scale(1.05);
        }

        .hint-modal {
            background: white;
            padding: 30px 40px;
            border-radius: 15px;
            max-width: 500px;
            text-align: left;
            animation: popIn 0.3s ease-out;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }

        .hint-modal h3 {
            color: #325aaf;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .hint-modal .technique {
            background: #e2ebf3;
            padding: 8px 15px;
            border-radius: 20px;
            color: #325aaf;
            font-size: 14px;
            font-weight: 600;
            display: inline-block;
            margin-bottom: 15px;
        }

        .hint-modal .explanation {
            color: #444;
            line-height: 1.7;
            margin-bottom: 20px;
        }

        .hint-modal .highlight-info {
            background: #fff3e0;
            padding: 12px 15px;
            border-radius: 8px;
            color: #e65100;
            font-size: 14px;
            margin-bottom: 20px;
        }

        .hint-modal .no-hint-warning {
            background: #ffebee;
            padding: 12px 15px;
            border-radius: 8px;
            color: #c62828;
            font-size: 14px;
            margin-bottom: 20px;
        }

        .hint-modal .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .hint-modal .close-btn {
            padding: 10px 25px;
            background: #325aaf;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .hint-modal .close-btn:hover {
            background: #1e3a6e;
        }

        .hint-modal .apply-btn {
            padding: 10px 25px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .hint-modal .apply-btn:hover {
            background: #388e3c;
        }

        .hint-modal .fill-notes-btn {
            padding: 10px 25px;
            background: #ff9800;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .hint-modal .fill-notes-btn:hover {
            background: #f57c00;
        }

        .confirm-modal {
            background: white;
            padding: 30px 40px;
            border-radius: 15px;
            max-width: 450px;
            text-align: center;
            animation: popIn 0.3s ease-out;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }

        .confirm-modal h3 {
            color: #344861;
            margin-bottom: 15px;
        }

        .confirm-modal p {
            color: #666;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .confirm-modal .changes-summary {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: left;
        }

        .confirm-modal .changes-summary ul {
            margin: 10px 0 0 20px;
        }

        .confirm-modal .btn-group {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .confirm-modal .cancel-btn {
            padding: 12px 25px;
            background: #9e9e9e;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .confirm-modal .cancel-btn:hover {
            background: #757575;
        }

        .confirm-modal .confirm-btn {
            padding: 12px 25px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .confirm-modal .confirm-btn:hover {
            background: #388e3c;
        }

        .check-modal {
            background: white;
            padding: 30px 40px;
            border-radius: 15px;
            max-width: 400px;
            text-align: center;
            animation: popIn 0.3s ease-out;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }

        .check-modal h3 {
            color: #344861;
            margin-bottom: 20px;
        }

        .check-modal .result {
            font-size: 1.2rem;
            color: #666;
            margin-bottom: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 10px;
        }

        .check-modal .result.perfect {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .check-modal .result.has-errors {
            background: #f7cfd6;
            color: #e55c6c;
        }

        .check-modal .btn-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .check-modal .modal-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .check-modal .close-btn {
            background: #9e9e9e;
            color: white;
        }

        .check-modal .close-btn:hover {
            background: #757575;
        }

        .check-modal .reveal-btn {
            background: #ff9800;
            color: white;
        }

        .check-modal .reveal-btn:hover {
            background: #f57c00;
        }

        .loading {
            color: #344861;
            font-size: 1.5rem;
            text-align: center;
            margin-top: 100px;
        }

        .loading .spinner {
            display: inline-block;
            width: 50px;
            height: 50px;
            border: 4px solid #e2ebf3;
            border-top-color: #325aaf;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 600px) {
            .cell {
                width: 38px;
                height: 38px;
                font-size: 18px;
            }
            .note {
                font-size: 8px;
            }
            .number-btn {
                width: 50px;
                height: 60px;
                font-size: 22px;
            }
            h1 {
                font-size: 1.8rem;
            }
            .stats-bar {
                gap: 15px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <h1>üß© Sudoku</h1>

    <div class="theory-banner" id="theoryBanner">
        üß™ THEORY MODE - Test your hypothesis without penalties!
    </div>

    <div class="difficulty-container">
        <button class="difficulty-btn" data-difficulty="easy">Easy</button>
        <button class="difficulty-btn active" data-difficulty="medium">Medium</button>
        <button class="difficulty-btn" data-difficulty="hard">Hard</button>
        <button class="difficulty-btn" data-difficulty="expert">Expert</button>
    </div>

    <div class="settings-container">
        <div class="setting-item">
            <input type="checkbox" id="autoCheckToggle" checked>
            <label for="autoCheckToggle">Auto-check answers</label>
        </div>
        <button class="check-answers-btn" id="checkAnswersBtn" style="display: none;">üìã Check Answers</button>
    </div>

    <div class="stats-bar">
        <div class="stat-item">
            <span>‚è±Ô∏è</span>
            <span class="timer" id="timer">00:00</span>
            <button class="pause-btn" id="pauseBtn">‚è∏Ô∏è</button>
        </div>
        <div class="stat-item">
            <span>‚ùå</span>
            <span>Mistakes: <span id="mistakes">0</span>/3</span>
        </div>
        <div class="stat-item">
            <span>üí°</span>
            <span>Hints: <span id="hintsRemaining">3</span></span>
        </div>
    </div>

    <div class="game-container">
        <div class="board-wrapper">
            <div class="board" id="board"></div>
            <div class="pause-overlay" id="pauseOverlay" style="display: none;">
                <div class="icon">‚è∏Ô∏è</div>
                <div class="text">Game Paused</div>
                <button class="resume-btn" id="resumeBtn">Resume</button>
            </div>
        </div>

        <div class="controls">
            <div class="number-pad" id="numberPad"></div>
            <div class="action-buttons">
                <button class="action-btn" id="notesBtn">‚úèÔ∏è Notes OFF</button>
                <button class="action-btn" id="hintBtn">üí° Hint (3)</button>
                <button class="action-btn" id="undoBtn">‚Ü©Ô∏è Undo</button>
                <button class="action-btn" id="eraseBtn">üóëÔ∏è Erase</button>
                <button class="action-btn" id="newGameBtn">üîÑ New Game</button>
            </div>

            <div class="theory-buttons">
                <button class="theory-btn enter" id="enterTheoryBtn">üß™ Enter Theory Mode</button>
                <button class="theory-btn apply" id="applyTheoryBtn" disabled>‚úÖ Apply Board</button>
                <button class="theory-btn revert" id="revertTheoryBtn" disabled>‚Ü©Ô∏è Revert to Saved</button>
            </div>

            <div class="keyboard-info">
                <strong>Keyboard Shortcuts:</strong>
                1-9: Enter number<br>
                N: Toggle notes<br>
                Arrows: Navigate<br>
                Delete: Erase<br>
                Ctrl+Z: Undo<br>
                T: Toggle Theory Mode
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="winModal" style="display: none;">
        <div class="modal">
            <div class="icon">üéâ</div>
            <h2>Congratulations!</h2>
            <p>You completed the <span id="winDifficulty">medium</span> puzzle!</p>
            <p class="stats">Time: <span id="winTime">00:00</span> | Mistakes: <span id="winMistakes">0</span></p>
            <button class="play-again-btn" id="playAgainBtn">Play Again</button>
        </div>
    </div>

    <div class="modal-overlay" id="hintModal" style="display: none;">
        <div class="hint-modal">
            <h3>üí° Hint</h3>
            <div class="technique" id="hintTechnique">Naked Single</div>
            <div class="explanation" id="hintExplanation"></div>
            <div class="highlight-info" id="hintHighlight"></div>
            <div class="no-hint-warning" id="noHintWarning" style="display: none;">
                No logical technique found with your current notes. Try filling in more notes or use the button below to auto-fill all possible candidates.
            </div>
            <div class="btn-group">
                <button class="close-btn" id="closeHintBtn">Got it!</button>
                <button class="apply-btn" id="applyHintBtn">Apply & Close</button>
                <button class="fill-notes-btn" id="fillNotesBtn">Fill All Notes</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="confirmApplyModal" style="display: none;">
        <div class="confirm-modal">
            <h3>üìã Apply Theory Board?</h3>
            <p>You are about to apply all changes made in Theory Mode to your actual game board.</p>
            <div class="changes-summary" id="changesSummary"></div>
            <p><strong>Note:</strong> Any numbers that conflict with Sudoku rules or are incorrect will be counted as mistakes.</p>
            <div class="btn-group">
                <button class="cancel-btn" id="cancelApplyBtn">Cancel</button>
                <button class="confirm-btn" id="confirmApplyBtn">Apply Changes</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="checkModal" style="display: none;">
        <div class="check-modal">
            <h3>üìã Check Results</h3>
            <div class="result" id="checkResult"></div>
            <div class="btn-group">
                <button class="modal-btn close-btn" id="closeCheckBtn">Close</button>
                <button class="modal-btn reveal-btn" id="revealErrorsBtn">Reveal Errors</button>
            </div>
        </div>
    </div>

    <script>
        class SudokuGame {
            constructor() {
                this.board = [];
                this.solution = [];
                this.notes = [];
                this.given = [];
                this.selectedCell = null;
                this.notesMode = false;
                this.hintsRemaining = 3;
                this.mistakes = 0;
                this.timer = 0;
                this.timerInterval = null;
                this.isPaused = false;
                this.history = [];
                this.difficulty = 'medium';
                this.hoveredNumber = null;
                this.currentHint = null;

                this.theoryMode = false;
                this.theorySavedState = null;

                this.autoCheck = true;
                this.revealedErrors = new Set();

                this.init();
            }

            init() {
                this.setupEventListeners();
                this.startNewGame('medium');
            }

            generatePuzzle(difficulty) {
                const solution = this.generateSolution();
                const puzzle = solution.map(row => [...row]);
                
                const cellsToRemove = {
                    easy: 35,
                    medium: 45,
                    hard: 52,
                    expert: 58
                };

                const cells = [];
                for (let i = 0; i < 81; i++) {
                    cells.push(i);
                }
                this.shuffle(cells);

                let removed = 0;
                for (const cellIndex of cells) {
                    if (removed >= cellsToRemove[difficulty]) break;
                    
                    const row = Math.floor(cellIndex / 9);
                    const col = cellIndex % 9;
                    
                    const backup = puzzle[row][col];
                    puzzle[row][col] = 0;
                    
                    if (this.countSolutions(puzzle.map(r => [...r])) === 1) {
                        removed++;
                    } else {
                        puzzle[row][col] = backup;
                    }
                }

                return { puzzle, solution };
            }

            generateSolution() {
                const board = Array(9).fill(null).map(() => Array(9).fill(0));
                this.solveSudoku(board, true);
                return board;
            }

            solveSudoku(board, randomize = false) {
                const empty = this.findEmpty(board);
                if (!empty) return true;

                const [row, col] = empty;
                let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                
                if (randomize) {
                    this.shuffle(nums);
                }

                for (const num of nums) {
                    if (this.isValidPlacement(board, row, col, num)) {
                        board[row][col] = num;
                        if (this.solveSudoku(board, randomize)) {
                            return true;
                        }
                        board[row][col] = 0;
                    }
                }

                return false;
            }

            countSolutions(board, limit = 2) {
                const empty = this.findEmpty(board);
                if (!empty) return 1;

                const [row, col] = empty;
                let count = 0;

                for (let num = 1; num <= 9; num++) {
                    if (this.isValidPlacement(board, row, col, num)) {
                        board[row][col] = num;
                        count += this.countSolutions(board, limit);
                        board[row][col] = 0;
                        if (count >= limit) return count;
                    }
                }

                return count;
            }

            findEmpty(board) {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (board[row][col] === 0) {
                            return [row, col];
                        }
                    }
                }
                return null;
            }

            isValidPlacement(board, row, col, num) {
                for (let x = 0; x < 9; x++) {
                    if (board[row][x] === num) return false;
                }

                for (let x = 0; x < 9; x++) {
                    if (board[x][col] === num) return false;
                }

                const boxRow = Math.floor(row / 3) * 3;
                const boxCol = Math.floor(col / 3) * 3;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (board[boxRow + i][boxCol + j] === num) return false;
                    }
                }

                return true;
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            startNewGame(difficulty) {
                if (this.theoryMode) {
                    this.exitTheoryMode(false);
                }

                this.difficulty = difficulty;
                this.showLoading(true);

                setTimeout(() => {
                    const { puzzle, solution } = this.generatePuzzle(difficulty);
                    
                    this.solution = solution;
                    this.board = puzzle.map(row => [...row]);
                    this.given = puzzle.map(row => row.map(cell => cell !== 0));
                    this.notes = Array(9).fill(null).map(() => 
                        Array(9).fill(null).map(() => new Set())
                    );
                    
                    this.selectedCell = null;
                    this.notesMode = false;
                    this.hintsRemaining = 3;
                    this.mistakes = 0;
                    this.timer = 0;
                    this.history = [];
                    this.isPaused = false;
                    this.currentHint = null;
                    this.theoryMode = false;
                    this.theorySavedState = null;
                    this.revealedErrors = new Set();

                    document.getElementById('mistakes').textContent = '0';
                    document.getElementById('hintsRemaining').textContent = '3';
                    document.getElementById('hintBtn').textContent = 'üí° Hint (3)';
                    document.getElementById('notesBtn').textContent = '‚úèÔ∏è Notes OFF';
                    document.getElementById('notesBtn').classList.remove('notes-active');

                    this.updateDifficultyButtons();
                    this.updateTheoryModeUI();
                    this.render();
                    this.startTimer();
                    this.showLoading(false);
                }, 50);
            }

            showLoading(show) {
                const board = document.getElementById('board');
                if (show) {
                    board.innerHTML = '<div class="loading"><div class="spinner"></div><br>Generating puzzle...</div>';
                    board.style.display = 'flex';
                    board.style.alignItems = 'center';
                    board.style.justifyContent = 'center';
                    board.style.width = '468px';
                    board.style.height = '468px';
                } else {
                    board.style.display = 'grid';
                    board.style.width = 'auto';
                    board.style.height = 'auto';
                }
            }

            saveState() {
                this.history.push({
                    board: this.board.map(row => [...row]),
                    notes: this.notes.map(row => row.map(cell => new Set(cell)))
                });
            }

            undo() {
                if (this.history.length === 0 || this.isPaused) return;
                
                const state = this.history.pop();
                this.board = state.board;
                this.notes = state.notes;
                this.render();
            }

            enterTheoryMode() {
                if (this.theoryMode || this.isPaused) return;

                this.theorySavedState = {
                    board: this.board.map(row => [...row]),
                    notes: this.notes.map(row => row.map(cell => new Set(cell))),
                    mistakes: this.mistakes,
                    history: this.history.map(h => ({
                        board: h.board.map(row => [...row]),
                        notes: h.notes.map(row => row.map(cell => new Set(cell)))
                    }))
                };

                this.theoryMode = true;
                this.history = [];

                this.updateTheoryModeUI();
                this.render();
            }

            exitTheoryMode(apply) {
                if (!this.theoryMode) return;

                if (apply) {
                    this.showApplyConfirmation();
                } else {
                    this.revertTheoryBoard();
                }
            }

            showApplyConfirmation() {
                const changes = this.getTheoryChanges();
                const summaryEl = document.getElementById('changesSummary');
                
                if (changes.numbersPlaced === 0 && changes.notesChanged === 0) {
                    summaryEl.innerHTML = '<p>No changes were made in Theory Mode.</p>';
                } else {
                    let html = '<ul>';
                    if (changes.numbersPlaced > 0) {
                        html += `<li><strong>${changes.numbersPlaced}</strong> number(s) placed</li>`;
                    }
                    if (changes.notesChanged > 0) {
                        html += `<li><strong>${changes.notesChanged}</strong> cell(s) with note changes</li>`;
                    }
                    html += '</ul>';
                    summaryEl.innerHTML = html;
                }

                document.getElementById('confirmApplyModal').style.display = 'flex';
            }

            getTheoryChanges() {
                const changes = {
                    numbersPlaced: 0,
                    notesChanged: 0,
                    placedCells: []
                };

                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (this.given[row][col]) continue;

                        const savedValue = this.theorySavedState.board[row][col];
                        const currentValue = this.board[row][col];

                        if (currentValue !== 0 && currentValue !== savedValue) {
                            changes.numbersPlaced++;
                            changes.placedCells.push({ row, col, value: currentValue });
                        }

                        const savedNotes = this.theorySavedState.notes[row][col];
                        const currentNotes = this.notes[row][col];
                        if (savedNotes.size !== currentNotes.size || 
                            ![...savedNotes].every(n => currentNotes.has(n))) {
                            changes.notesChanged++;
                        }
                    }
                }

                return changes;
            }

            confirmApplyTheoryBoard() {
                const changes = this.getTheoryChanges();
                
                let newMistakes = 0;
                for (const cell of changes.placedCells) {
                    if (cell.value !== this.solution[cell.row][cell.col]) {
                        newMistakes++;
                    }
                }
                
                this.mistakes = this.theorySavedState.mistakes + newMistakes;
                document.getElementById('mistakes').textContent = this.mistakes;

                this.theoryMode = false;
                this.theorySavedState = null;
                this.history = [];

                document.getElementById('confirmApplyModal').style.display = 'none';
                this.updateTheoryModeUI();
                this.render();

                if (this.checkWin()) {
                    this.showWinModal();
                }
            }

            revertTheoryBoard() {
                if (!this.theorySavedState) return;

                this.board = this.theorySavedState.board;
                this.notes = this.theorySavedState.notes;
                this.mistakes = this.theorySavedState.mistakes;
                this.history = this.theorySavedState.history || [];

                this.theoryMode = false;
                this.theorySavedState = null;

                document.getElementById('mistakes').textContent = this.mistakes;
                this.updateTheoryModeUI();
                this.render();
            }

            updateTheoryModeUI() {
                const banner = document.getElementById('theoryBanner');
                const enterBtn = document.getElementById('enterTheoryBtn');
                const applyBtn = document.getElementById('applyTheoryBtn');
                const revertBtn = document.getElementById('revertTheoryBtn');

                if (this.theoryMode) {
                    document.body.classList.add('theory-mode');
                    banner.classList.add('active');
                    enterBtn.disabled = true;
                    enterBtn.textContent = 'üß™ In Theory Mode';
                    applyBtn.disabled = false;
                    revertBtn.disabled = false;
                } else {
                    document.body.classList.remove('theory-mode');
                    banner.classList.remove('active');
                    enterBtn.disabled = false;
                    enterBtn.textContent = 'üß™ Enter Theory Mode';
                    applyBtn.disabled = true;
                    revertBtn.disabled = true;
                }
            }

            startTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                this.timerInterval = setInterval(() => {
                    if (!this.isPaused) {
                        this.timer++;
                        this.updateTimerDisplay();
                    }
                }, 1000);
            }

            updateTimerDisplay() {
                const mins = Math.floor(this.timer / 60).toString().padStart(2, '0');
                const secs = (this.timer % 60).toString().padStart(2, '0');
                document.getElementById('timer').textContent = `${mins}:${secs}`;
            }

            togglePause() {
                this.isPaused = !this.isPaused;
                document.getElementById('pauseBtn').textContent = this.isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
                document.getElementById('pauseOverlay').style.display = this.isPaused ? 'flex' : 'none';
            }

            isNumberCompleted(num) {
                let count = 0;
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (this.board[row][col] === num && this.board[row][col] === this.solution[row][col]) {
                            count++;
                        }
                    }
                }
                return count >= 9;
            }

            getCorrectNumberCount(num) {
                let count = 0;
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (this.board[row][col] === num && this.board[row][col] === this.solution[row][col]) {
                            count++;
                        }
                    }
                }
                return count;
            }

            selectCell(row, col) {
                if (this.isPaused) return;
                this.selectedCell = { row, col };
                this.render();
            }

            inputNumber(num) {
                if (!this.selectedCell || this.isPaused) return;
                
                const { row, col } = this.selectedCell;
                if (this.given[row][col]) return;

                const currentValue = this.board[row][col];

                if (currentValue === num && currentValue !== this.solution[row][col]) {
                    this.saveState();
                    this.board[row][col] = 0;
                    this.render();
                    return;
                }

                if (currentValue !== 0 && currentValue === this.solution[row][col]) {
                    return;
                }

                if (this.isNumberCompleted(num)) {
                    return;
                }

                this.saveState();

                if (this.notesMode) {
                    if (this.board[row][col] === 0) {
                        if (this.notes[row][col].has(num)) {
                            this.notes[row][col].delete(num);
                        } else {
                            this.notes[row][col].add(num);
                        }
                    }
                } else {
                    if (this.autoCheck && !this.theoryMode) {
                        if (num !== this.solution[row][col]) {
                            this.mistakes++;
                            document.getElementById('mistakes').textContent = this.mistakes;
                        }
                    }
                    
                    this.board[row][col] = num;
                    this.notes[row][col].clear();
                    this.removeNotesFromRelated(row, col, num);
                    
                    if (!this.theoryMode && this.checkWin()) {
                        this.showWinModal();
                    }
                }

                this.render();
            }

            eraseCell() {
                if (!this.selectedCell || this.isPaused) return;
                
                const { row, col } = this.selectedCell;
                if (this.given[row][col]) return;

                const currentValue = this.board[row][col];

                if (currentValue !== 0 && currentValue === this.solution[row][col]) {
                    return;
                }

                this.saveState();
                this.board[row][col] = 0;
                this.notes[row][col].clear();
                this.render();
            }

            removeNotesFromRelated(row, col, num) {
                for (let x = 0; x < 9; x++) {
                    this.notes[row][x].delete(num);
                }

                for (let x = 0; x < 9; x++) {
                    this.notes[x][col].delete(num);
                }

                const boxRow = Math.floor(row / 3) * 3;
                const boxCol = Math.floor(col / 3) * 3;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        this.notes[boxRow + i][boxCol + j].delete(num);
                    }
                }
            }

            toggleNotes() {
                this.notesMode = !this.notesMode;
                document.getElementById('notesBtn').textContent = `‚úèÔ∏è Notes ${this.notesMode ? 'ON' : 'OFF'}`;
                document.getElementById('notesBtn').classList.toggle('notes-active', this.notesMode);
            }

            toggleAutoCheck() {
                this.autoCheck = !this.autoCheck;
                document.getElementById('autoCheckToggle').checked = this.autoCheck;
                document.getElementById('checkAnswersBtn').style.display = this.autoCheck ? 'none' : 'inline-block';
                this.revealedErrors.clear();
                this.render();
            }

            checkAnswers() {
                let errorCount = 0;
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (this.board[row][col] !== 0 && !this.given[row][col]) {
                            if (this.board[row][col] !== this.solution[row][col]) {
                                errorCount++;
                            }
                        }
                    }
                }

                const resultEl = document.getElementById('checkResult');
                const revealBtn = document.getElementById('revealErrorsBtn');

                if (errorCount === 0) {
                    resultEl.textContent = '‚úì All filled cells are correct!';
                    resultEl.className = 'result perfect';
                    revealBtn.style.display = 'none';
                } else {
                    resultEl.textContent = `‚úó You have ${errorCount} incorrect cell${errorCount > 1 ? 's' : ''}.`;
                    resultEl.className = 'result has-errors';
                    revealBtn.style.display = 'inline-block';
                }

                document.getElementById('checkModal').style.display = 'flex';
            }

            revealErrors() {
                this.revealedErrors.clear();
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (this.board[row][col] !== 0 && !this.given[row][col]) {
                            if (this.board[row][col] !== this.solution[row][col]) {
                                this.revealedErrors.add(`${row},${col}`);
                            }
                        }
                    }
                }
                document.getElementById('checkModal').style.display = 'none';
                this.render();
            }

            isError(row, col) {
                if (this.given[row][col]) return false;
                if (this.board[row][col] === 0) return false;
                
                if (this.autoCheck && !this.theoryMode) {
                    return this.board[row][col] !== this.solution[row][col];
                }

                if (this.revealedErrors.has(`${row},${col}`)) {
                    return true;
                }

                return false;
            }

            getHint() {
                if (this.hintsRemaining <= 0 || this.isPaused) return;

                const allHints = [];

                const nakedSingles = this.findAllNakedSingles();
                nakedSingles.forEach(h => allHints.push({ technique: 'Naked Single', hint: h }));

                const hiddenSingles = this.findAllHiddenSingles();
                hiddenSingles.forEach(h => allHints.push({ technique: 'Hidden Single', hint: h }));

                const pointingPairs = this.findAllPointingPairs();
                pointingPairs.forEach(h => allHints.push({ technique: 'Pointing Pair', hint: h }));

                const boxLineReductions = this.findAllBoxLineReductions();
                boxLineReductions.forEach(h => allHints.push({ technique: 'Box/Line Reduction', hint: h }));

                const nakedPairs = this.findAllNakedPairs();
                nakedPairs.forEach(h => allHints.push({ technique: 'Naked Pair', hint: h }));

                if (allHints.length > 0) {
                    const randomIndex = Math.floor(Math.random() * allHints.length);
                    const selected = allHints[randomIndex];
                    this.currentHint = selected.hint;
                    this.showHintModal(selected.technique, selected.hint, true);
                } else {
                    this.showHintModal('No Technique Found', null, false);
                }
            }

            findAllNakedSingles() {
                const hints = [];
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (this.board[row][col] === 0) {
                            const candidates = [];
                            for (let num = 1; num <= 9; num++) {
                                if (this.isValidPlacement(this.board, row, col, num)) {
                                    candidates.push(num);
                                }
                            }
                            if (candidates.length === 1) {
                                hints.push({
                                    type: 'place',
                                    row,
                                    col,
                                    value: candidates[0],
                                    explanation: `Look at the cell in row ${row + 1}, column ${col + 1}. After checking all the numbers that appear in its row, column, and 3x3 box, there's only ONE number that can go here: ${candidates[0]}. This is because all other numbers (1-9) are already present in either the same row, column, or box.`,
                                    highlight: `The cell at R${row + 1}C${col + 1} can only be ${candidates[0]}.`
                                });
                            }
                        }
                    }
                }
                return hints;
            }

            findAllHiddenSingles() {
                const hints = [];

                for (let row = 0; row < 9; row++) {
                    for (let num = 1; num <= 9; num++) {
                        if (this.rowHas(row, num)) continue;
                        
                        const positions = [];
                        for (let col = 0; col < 9; col++) {
                            if (this.board[row][col] === 0 && this.isValidPlacement(this.board, row, col, num)) {
                                positions.push(col);
                            }
                        }
                        
                        if (positions.length === 1) {
                            const col = positions[0];
                            hints.push({
                                type: 'place',
                                row,
                                col,
                                value: num,
                                explanation: `In row ${row + 1}, the number ${num} can only go in one position. Even though the cell at column ${col + 1} might have other candidates, ${num} cannot go anywhere else in this row because all other empty cells in the row either already see a ${num} in their column or 3x3 box.`,
                                highlight: `${num} must go in R${row + 1}C${col + 1} - it's the only place in row ${row + 1} where it fits!`
                            });
                        }
                    }
                }

                for (let col = 0; col < 9; col++) {
                    for (let num = 1; num <= 9; num++) {
                        if (this.colHas(col, num)) continue;
                        
                        const positions = [];
                        for (let row = 0; row < 9; row++) {
                            if (this.board[row][col] === 0 && this.isValidPlacement(this.board, row, col, num)) {
                                positions.push(row);
                            }
                        }
                        
                        if (positions.length === 1) {
                            const row = positions[0];
                            hints.push({
                                type: 'place',
                                row,
                                col,
                                value: num,
                                explanation: `In column ${col + 1}, the number ${num} can only go in one position. Looking at all empty cells in this column, only the cell at row ${row + 1} can contain ${num}. All other empty cells in the column are blocked by ${num}s in their row or 3x3 box.`,
                                highlight: `${num} must go in R${row + 1}C${col + 1} - it's the only place in column ${col + 1} where it fits!`
                            });
                        }
                    }
                }

                for (let boxRow = 0; boxRow < 3; boxRow++) {
                    for (let boxCol = 0; boxCol < 3; boxCol++) {
                        for (let num = 1; num <= 9; num++) {
                            if (this.boxHas(boxRow, boxCol, num)) continue;
                            
                            const positions = [];
                            for (let i = 0; i < 3; i++) {
                                for (let j = 0; j < 3; j++) {
                                    const row = boxRow * 3 + i;
                                    const col = boxCol * 3 + j;
                                    if (this.board[row][col] === 0 && this.isValidPlacement(this.board, row, col, num)) {
                                        positions.push({ row, col });
                                    }
                                }
                            }
                            
                            if (positions.length === 1) {
                                const { row, col } = positions[0];
                                const boxNum = boxRow * 3 + boxCol + 1;
                                hints.push({
                                    type: 'place',
                                    row,
                                    col,
                                    value: num,
                                    explanation: `In box ${boxNum} (the 3x3 box containing this cell), the number ${num} can only go in one position. All other empty cells in this box are blocked by ${num}s appearing in their respective rows or columns.`,
                                    highlight: `${num} must go in R${row + 1}C${col + 1} - it's the only place in box ${boxNum} where it fits!`
                                });
                            }
                        }
                    }
                }

                return hints;
            }

            findAllPointingPairs() {
                const hints = [];

                for (let boxRow = 0; boxRow < 3; boxRow++) {
                    for (let boxCol = 0; boxCol < 3; boxCol++) {
                        for (let num = 1; num <= 9; num++) {
                            if (this.boxHas(boxRow, boxCol, num)) continue;

                            const positions = [];
                            for (let i = 0; i < 3; i++) {
                                for (let j = 0; j < 3; j++) {
                                    const row = boxRow * 3 + i;
                                    const col = boxCol * 3 + j;
                                    if (this.board[row][col] === 0 && this.notes[row][col].has(num)) {
                                        positions.push({ row, col });
                                    }
                                }
                            }

                            if (positions.length >= 2) {
                                const rows = [...new Set(positions.map(p => p.row))];
                                if (rows.length === 1) {
                                    const row = rows[0];
                                    let canEliminate = false;
                                    for (let col = 0; col < 9; col++) {
                                        const inBox = col >= boxCol * 3 && col < boxCol * 3 + 3;
                                        if (!inBox && this.notes[row][col].has(num)) {
                                            canEliminate = true;
                                        }
                                    }
                                    if (canEliminate) {
                                        const boxNum = boxRow * 3 + boxCol + 1;
                                        hints.push({
                                            type: 'eliminate',
                                            explanation: `In box ${boxNum}, the number ${num} can only appear in row ${row + 1}. This means ${num} cannot appear anywhere else in row ${row + 1} outside this box. You can eliminate ${num} from the notes of other cells in row ${row + 1}.`,
                                            highlight: `Pointing Pair: ${num} in box ${boxNum} points along row ${row + 1}. Remove ${num} from other cells in this row.`
                                        });
                                    }
                                }

                                const cols = [...new Set(positions.map(p => p.col))];
                                if (cols.length === 1) {
                                    const col = cols[0];
                                    let canEliminate = false;
                                    for (let row = 0; row < 9; row++) {
                                        const inBox = row >= boxRow * 3 && row < boxRow * 3 + 3;
                                        if (!inBox && this.notes[row][col].has(num)) {
                                            canEliminate = true;
                                        }
                                    }
                                    if (canEliminate) {
                                        const boxNum = boxRow * 3 + boxCol + 1;
                                        hints.push({
                                            type: 'eliminate',
                                            explanation: `In box ${boxNum}, the number ${num} can only appear in column ${col + 1}. This means ${num} cannot appear anywhere else in column ${col + 1} outside this box. You can eliminate ${num} from the notes of other cells in column ${col + 1}.`,
                                            highlight: `Pointing Pair: ${num} in box ${boxNum} points along column ${col + 1}. Remove ${num} from other cells in this column.`
                                        });
                                    }
                                }
                            }
                        }
                    }
                }

                return hints;
            }

            findAllBoxLineReductions() {
                const hints = [];

                for (let row = 0; row < 9; row++) {
                    for (let num = 1; num <= 9; num++) {
                        if (this.rowHas(row, num)) continue;

                        const positions = [];
                        for (let col = 0; col < 9; col++) {
                            if (this.board[row][col] === 0 && this.notes[row][col].has(num)) {
                                positions.push({ row, col });
                            }
                        }

                        if (positions.length >= 2 && positions.length <= 3) {
                            const boxes = [...new Set(positions.map(p => Math.floor(p.col / 3)))];
                            if (boxes.length === 1) {
                                const boxCol = boxes[0];
                                const boxRow = Math.floor(row / 3);
                                
                                let canEliminate = false;
                                for (let i = 0; i < 3; i++) {
                                    for (let j = 0; j < 3; j++) {
                                        const r = boxRow * 3 + i;
                                        const c = boxCol * 3 + j;
                                        if (r !== row && this.notes[r][c].has(num)) {
                                            canEliminate = true;
                                        }
                                    }
                                }

                                if (canEliminate) {
                                    const boxNum = boxRow * 3 + boxCol + 1;
                                    hints.push({
                                        type: 'eliminate',
                                        explanation: `In row ${row + 1}, the number ${num} can only appear within box ${boxNum}. This means ${num} must be in row ${row + 1} of this box, so it can be eliminated from other rows within the same box.`,
                                        highlight: `Box/Line Reduction: ${num} in row ${row + 1} is confined to box ${boxNum}. Remove ${num} from other rows in that box.`
                                    });
                                }
                            }
                        }
                    }
                }

                for (let col = 0; col < 9; col++) {
                    for (let num = 1; num <= 9; num++) {
                        if (this.colHas(col, num)) continue;

                        const positions = [];
                        for (let row = 0; row < 9; row++) {
                            if (this.board[row][col] === 0 && this.notes[row][col].has(num)) {
                                positions.push({ row, col });
                            }
                        }

                        if (positions.length >= 2 && positions.length <= 3) {
                            const boxes = [...new Set(positions.map(p => Math.floor(p.row / 3)))];
                            if (boxes.length === 1) {
                                const boxRow = boxes[0];
                                const boxCol = Math.floor(col / 3);
                                
                                let canEliminate = false;
                                for (let i = 0; i < 3; i++) {
                                    for (let j = 0; j < 3; j++) {
                                        const r = boxRow * 3 + i;
                                        const c = boxCol * 3 + j;
                                        if (c !== col && this.notes[r][c].has(num)) {
                                            canEliminate = true;
                                        }
                                    }
                                }

                                if (canEliminate) {
                                    const boxNum = boxRow * 3 + boxCol + 1;
                                    hints.push({
                                        type: 'eliminate',
                                        explanation: `In column ${col + 1}, the number ${num} can only appear within box ${boxNum}. This means ${num} must be in column ${col + 1} of this box, so it can be eliminated from other columns within the same box.`,
                                        highlight: `Box/Line Reduction: ${num} in column ${col + 1} is confined to box ${boxNum}. Remove ${num} from other columns in that box.`
                                    });
                                }
                            }
                        }
                    }
                }

                return hints;
            }

            findAllNakedPairs() {
                const hints = [];

                for (let row = 0; row < 9; row++) {
                    const cells = [];
                    for (let col = 0; col < 9; col++) {
                        if (this.board[row][col] === 0 && this.notes[row][col].size === 2) {
                            cells.push({ col, notes: [...this.notes[row][col]].sort().join(',') });
                        }
                    }

                    for (let i = 0; i < cells.length; i++) {
                        for (let j = i + 1; j < cells.length; j++) {
                            if (cells[i].notes === cells[j].notes) {
                                const pair = cells[i].notes.split(',').map(Number);
                                let canEliminate = false;
                                
                                for (let col = 0; col < 9; col++) {
                                    if (col !== cells[i].col && col !== cells[j].col) {
                                        if (this.notes[row][col].has(pair[0]) || this.notes[row][col].has(pair[1])) {
                                            canEliminate = true;
                                        }
                                    }
                                }

                                if (canEliminate) {
                                    hints.push({
                                        type: 'eliminate',
                                        explanation: `Cells at columns ${cells[i].col + 1} and ${cells[j].col + 1} in row ${row + 1} both can only contain ${pair[0]} or ${pair[1]}. Since these two numbers must go in these two cells, you can eliminate ${pair[0]} and ${pair[1]} from all other cells in the same row.`,
                                        highlight: `Naked Pair: ${pair[0]} and ${pair[1]} are locked in two cells of row ${row + 1}. Remove them from other cells in the row.`
                                    });
                                }
                            }
                        }
                    }
                }

                for (let col = 0; col < 9; col++) {
                    const cells = [];
                    for (let row = 0; row < 9; row++) {
                        if (this.board[row][col] === 0 && this.notes[row][col].size === 2) {
                            cells.push({ row, notes: [...this.notes[row][col]].sort().join(',') });
                        }
                    }

                    for (let i = 0; i < cells.length; i++) {
                        for (let j = i + 1; j < cells.length; j++) {
                            if (cells[i].notes === cells[j].notes) {
                                const pair = cells[i].notes.split(',').map(Number);
                                let canEliminate = false;
                                
                                for (let row = 0; row < 9; row++) {
                                    if (row !== cells[i].row && row !== cells[j].row) {
                                        if (this.notes[row][col].has(pair[0]) || this.notes[row][col].has(pair[1])) {
                                            canEliminate = true;
                                        }
                                    }
                                }

                                if (canEliminate) {
                                    hints.push({
                                        type: 'eliminate',
                                        explanation: `Cells at rows ${cells[i].row + 1} and ${cells[j].row + 1} in column ${col + 1} both can only contain ${pair[0]} or ${pair[1]}. Since these two numbers must go in these two cells, you can eliminate ${pair[0]} and ${pair[1]} from all other cells in the same column.`,
                                        highlight: `Naked Pair: ${pair[0]} and ${pair[1]} are locked in two cells of column ${col + 1}. Remove them from other cells in the column.`
                                    });
                                }
                            }
                        }
                    }
                }

                return hints;
            }

            fillAllNotes() {
                this.saveState();
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (this.board[row][col] === 0) {
                            this.notes[row][col].clear();
                            for (let num = 1; num <= 9; num++) {
                                if (this.isValidPlacement(this.board, row, col, num)) {
                                    this.notes[row][col].add(num);
                                }
                            }
                        }
                    }
                }
                this.render();
                document.getElementById('hintModal').style.display = 'none';
                
                setTimeout(() => this.getHint(), 100);
            }

            showHintModal(technique, hint, found) {
                document.getElementById('hintTechnique').textContent = technique;
                
                if (found && hint) {
                    document.getElementById('hintExplanation').textContent = hint.explanation;
                    document.getElementById('hintExplanation').style.display = 'block';
                    document.getElementById('hintHighlight').textContent = hint.highlight;
                    document.getElementById('hintHighlight').style.display = 'block';
                    document.getElementById('noHintWarning').style.display = 'none';
                    document.getElementById('applyHintBtn').style.display = hint.type === 'place' ? 'inline-block' : 'none';
                    document.getElementById('fillNotesBtn').style.display = 'none';

                    if (hint.row !== undefined && hint.col !== undefined) {
                        this.selectedCell = { row: hint.row, col: hint.col };
                        this.render();
                    }
                } else {
                    document.getElementById('hintExplanation').style.display = 'none';
                    document.getElementById('hintHighlight').style.display = 'none';
                    document.getElementById('noHintWarning').style.display = 'block';
                    document.getElementById('applyHintBtn').style.display = 'none';
                    document.getElementById('fillNotesBtn').style.display = 'inline-block';
                }

                document.getElementById('hintModal').style.display = 'flex';
            }

            applyHint() {
                if (!this.currentHint || this.currentHint.type !== 'place') return;
                
                this.hintsRemaining--;
                document.getElementById('hintsRemaining').textContent = this.hintsRemaining;
                document.getElementById('hintBtn').textContent = `üí° Hint (${this.hintsRemaining})`;
                
                this.saveState();
                const { row, col, value } = this.currentHint;
                this.board[row][col] = value;
                this.notes[row][col].clear();
                this.removeNotesFromRelated(row, col, value);
                
                if (this.checkWin()) {
                    this.showWinModal();
                }

                this.currentHint = null;
                document.getElementById('hintModal').style.display = 'none';
                this.render();
            }

            rowHas(row, num) {
                for (let col = 0; col < 9; col++) {
                    if (this.board[row][col] === num) return true;
                }
                return false;
            }

            colHas(col, num) {
                for (let row = 0; row < 9; row++) {
                    if (this.board[row][col] === num) return true;
                }
                return false;
            }

            boxHas(boxRow, boxCol, num) {
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (this.board[boxRow * 3 + i][boxCol * 3 + j] === num) return true;
                    }
                }
                return false;
            }

            checkWin() {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (this.board[row][col] !== this.solution[row][col]) {
                            return false;
                        }
                    }
                }
                return true;
            }

            showWinModal() {
                clearInterval(this.timerInterval);
                document.getElementById('winDifficulty').textContent = this.difficulty;
                document.getElementById('winTime').textContent = document.getElementById('timer').textContent;
                document.getElementById('winMistakes').textContent = this.mistakes;
                document.getElementById('winModal').style.display = 'flex';
            }

            render() {
                this.renderBoard();
                this.renderNumberPad();
            }

            renderBoard() {
                const boardEl = document.getElementById('board');
                boardEl.innerHTML = '';

                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        
                        if ((col + 1) % 3 === 0 && col !== 8) cell.classList.add('border-right');
                        if ((row + 1) % 3 === 0 && row !== 8) cell.classList.add('border-bottom');
                        
                        if (this.selectedCell) {
                            const { row: selRow, col: selCol } = this.selectedCell;
                            
                            if (row === selRow || col === selCol) {
                                cell.classList.add('highlighted-row-col');
                            }
                            
                            const selBoxRow = Math.floor(selRow / 3);
                            const selBoxCol = Math.floor(selCol / 3);
                            if (Math.floor(row / 3) === selBoxRow && Math.floor(col / 3) === selBoxCol) {
                                cell.classList.add('highlighted-box');
                            }
                            
                            if (this.board[row][col] !== 0 && 
                                this.board[row][col] === this.board[selRow][selCol]) {
                                cell.classList.add('same-number');
                            }
                            
                            if (row === selRow && col === selCol) {
                                cell.classList.add('selected');
                            }
                        }

                        if (this.hoveredNumber && this.board[row][col] === this.hoveredNumber) {
                            cell.classList.add('hover-highlight');
                        }

                        if (this.given[row][col]) {
                            cell.classList.add('given');
                        }

                        if (!this.given[row][col] && this.board[row][col] !== 0 && 
                            this.board[row][col] === this.solution[row][col]) {
                            cell.classList.add('correct');
                        }

                        if (this.isError(row, col)) {
                            cell.classList.add('error');
                        }

                        if (this.revealedErrors.has(`${row},${col}`)) {
                            cell.classList.add('revealed-error');
                        }

                        if (this.theoryMode && this.theorySavedState) {
                            const savedValue = this.theorySavedState.board[row][col];
                            const currentValue = this.board[row][col];
                            if (currentValue !== 0 && currentValue !== savedValue && !this.given[row][col]) {
                                cell.classList.add('theory-placed');
                            }
                        }

                        let highlightNoteNumber = this.hoveredNumber;
                        if (!highlightNoteNumber && this.selectedCell) {
                            const selVal = this.board[this.selectedCell.row][this.selectedCell.col];
                            if (selVal !== 0) {
                                highlightNoteNumber = selVal;
                            }
                        }

                        if (this.board[row][col] !== 0) {
                            cell.textContent = this.board[row][col];
                        } else if (this.notes[row][col].size > 0) {
                            const notesGrid = document.createElement('div');
                            notesGrid.className = 'notes-grid';
                            for (let n = 1; n <= 9; n++) {
                                const noteSpan = document.createElement('span');
                                noteSpan.className = 'note';
                                if (this.notes[row][col].has(n)) {
                                    noteSpan.textContent = n;
                                    if (highlightNoteNumber === n) {
                                        noteSpan.classList.add('highlighted-note');
                                    }
                                }
                                notesGrid.appendChild(noteSpan);
                            }
                            cell.appendChild(notesGrid);
                        }

                        const r = row;
                        const c = col;
                        
cell.addEventListener('click', (e) => {
    e.stopPropagation();
    this.selectCell(r, c);
});                        
                        cell.addEventListener('mouseenter', () => {
                            const num = this.board[r][c];
                            if (num !== 0 && this.hoveredNumber !== num) {
                                this.hoveredNumber = num;
                                this.renderBoard();
                            }
                        });

                        boardEl.appendChild(cell);
                    }
                }

                boardEl.addEventListener('mouseleave', () => {
                    if (this.hoveredNumber !== null) {
                        this.hoveredNumber = null;
                        this.renderBoard();
                    }
                });
            }

            renderNumberPad() {
                const padEl = document.getElementById('numberPad');
                padEl.innerHTML = '';

                for (let num = 1; num <= 9; num++) {
                    const btn = document.createElement('button');
                    btn.className = 'number-btn';
                    
                    const count = this.getCorrectNumberCount(num);
                    const isCompleted = count >= 9;
                    if (isCompleted) btn.classList.add('completed');

                    btn.innerHTML = `${num}<span class="count">${count}/9</span>`;
                    
                    btn.addEventListener('click', () => {
                        if (!isCompleted) this.inputNumber(num);
                    });
                    btn.addEventListener('mouseenter', () => {
                        this.hoveredNumber = num;
                        this.render();
                    });
                    btn.addEventListener('mouseleave', () => {
                        this.hoveredNumber = null;
                        this.render();
                    });

                    padEl.appendChild(btn);
                }
            }

            updateDifficultyButtons() {
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.difficulty === this.difficulty);
                });
            }

setupEventListeners() {
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            this.startNewGame(btn.dataset.difficulty);
        });
    });

    document.getElementById('pauseBtn').addEventListener('click', () => this.togglePause());
    document.getElementById('resumeBtn').addEventListener('click', () => this.togglePause());

    document.getElementById('notesBtn').addEventListener('click', () => this.toggleNotes());
    document.getElementById('hintBtn').addEventListener('click', () => this.getHint());
    document.getElementById('undoBtn').addEventListener('click', () => this.undo());
    document.getElementById('eraseBtn').addEventListener('click', () => this.eraseCell());
    document.getElementById('newGameBtn').addEventListener('click', () => this.startNewGame(this.difficulty));

    document.getElementById('autoCheckToggle').addEventListener('change', (e) => {
        this.autoCheck = e.target.checked;
        document.getElementById('checkAnswersBtn').style.display = this.autoCheck ? 'none' : 'inline-block';
        this.revealedErrors.clear();
        this.render();
    });

    document.getElementById('checkAnswersBtn').addEventListener('click', () => this.checkAnswers());
    document.getElementById('closeCheckBtn').addEventListener('click', () => {
        document.getElementById('checkModal').style.display = 'none';
    });
    document.getElementById('revealErrorsBtn').addEventListener('click', () => this.revealErrors());

    document.getElementById('enterTheoryBtn').addEventListener('click', () => this.enterTheoryMode());
    document.getElementById('applyTheoryBtn').addEventListener('click', () => this.exitTheoryMode(true));
    document.getElementById('revertTheoryBtn').addEventListener('click', () => this.exitTheoryMode(false));

    document.getElementById('cancelApplyBtn').addEventListener('click', () => {
        document.getElementById('confirmApplyModal').style.display = 'none';
    });
    document.getElementById('confirmApplyBtn').addEventListener('click', () => this.confirmApplyTheoryBoard());

    document.getElementById('playAgainBtn').addEventListener('click', () => {
        document.getElementById('winModal').style.display = 'none';
        this.startNewGame(this.difficulty);
    });

    document.getElementById('closeHintBtn').addEventListener('click', () => {
        document.getElementById('hintModal').style.display = 'none';
        this.currentHint = null;
    });
    document.getElementById('applyHintBtn').addEventListener('click', () => this.applyHint());
    document.getElementById('fillNotesBtn').addEventListener('click', () => this.fillAllNotes());

    document.addEventListener('keydown', (e) => {
        if (this.isPaused) return;

        const hintModalOpen = document.getElementById('hintModal').style.display === 'flex';
        const confirmModalOpen = document.getElementById('confirmApplyModal').style.display === 'flex';
        const winModalOpen = document.getElementById('winModal').style.display === 'flex';
        const checkModalOpen = document.getElementById('checkModal').style.display === 'flex';
        
        if (hintModalOpen || confirmModalOpen || winModalOpen || checkModalOpen) return;

        const num = parseInt(e.key);
        if (num >= 1 && num <= 9) {
            this.inputNumber(num);
        } else if (e.key === 'Backspace' || e.key === 'Delete') {
            this.eraseCell();
        } else if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            this.undo();
        } else if (e.key === 'n' || e.key === 'N') {
            this.toggleNotes();
        } else if (e.key === 't' || e.key === 'T') {
            if (this.theoryMode) {
                this.exitTheoryMode(false);
            } else {
                this.enterTheoryMode();
            }
        } else if (this.selectedCell) {
            let { row, col } = this.selectedCell;
            if (e.key === 'ArrowUp') row = Math.max(0, row - 1);
            if (e.key === 'ArrowDown') row = Math.min(8, row + 1);
            if (e.key === 'ArrowLeft') col = Math.max(0, col - 1);
            if (e.key === 'ArrowRight') col = Math.min(8, col + 1);
            
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                this.selectCell(row, col);
            }
        }
    });

    document.addEventListener('click', (e) => {
        const board = document.getElementById('board');
        const controls = document.querySelector('.controls');
        
        if (!board.contains(e.target) && !controls.contains(e.target)) {
            this.selectedCell = null;
            this.render();
        }
    });
}
}
        

        const game = new SudokuGame();
    </script>
</body>
</html>